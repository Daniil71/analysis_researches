Краткое описание БД - из каких таблиц и представлений состоит.
      
       БД состоит из 8 таблиц , 1 представления и 1 материализованного представления:    
 	 
	таблицы:              
	- aircrafts
- airports
- boarding_passes
- bookings
- flights
- seats
- ticket_flights
- tickets
       
       
       представление :
 -  flights_v
		
	 материализованное представление:
	- routes


4. Развернутый анализ БД - описание таблиц, логики, связей и бизнес области (частично можно взять из описания базы данных, оформленной в виде анализа базы данных). Бизнес задачи, которые можно решить, используя БД.
 
	Центральной таблицей БД является flights, с которой связывается целый блок таблиц с данными о билетах, пассажирах и бронировании через суррогатный первичный ключ flight_id. Сама таблица flights содержит внешние ключи на  aircrafts и airports, которые вместе с seats можно назвать вспомогательными таблицами БД. Во flights содержится вся совокупность рейсов/перелётов с номером рейса, который в сочетании с планируемыми датой и временем является  уникальным, с данными по аэропортам вылета и прилёта,  планируемом и действительном времени вылетов и прилётов, кодами самолёта, совершавшего рейс, и статусом рейса.

	Таблица airports содержит коды аэропортов (первичный ключ таблицы), их названия, города расположения, географические координаты и часовой пояс.
	
	Таблица aircrafts содержит коды самолётов (первичный ключ таблицы), название модели и предельную дальность полёта.

	Таблица seats содержит номер каждого места,вместе с  кодом самолёта (внешний ключ на aircrafts) являющийся первичным ключом таблицы, и степень их комфортности.

	В блоке данных с билетами и пассажирами в таблице bookings содержатся номера брони(первичный ключ таблицы), полная их стоимость и даты бронирования. В одну бронь при этом могут включаться несколько билетов из таблицы tickets. Сам номер билета уникален (первичный ключ) . Только в этой таблице хранятся данные о пассажирах с ФИО, паспортными данными и контактной информацией.

	Таблица tickets связывается с справочной таблицей  ticket_flights, суррогатный первичный ключ из flight_id и ticket_id. Только в этой таблице есть стоимость непосредственно билета.
	Справочная таблица boarding_passes содержит данные о пассажирах, фактически попавших на рейс (получивших посадочный талон) с указанием конкретного места в самолёте. Первичный ключ таблицы тот же, что и в ticket_flights. То есть, имеются две таблицы, рассматривающие пару билет-рейс с разных аспектов бизнеса: финансовая составляющая со стоимостью и условиями перелёта в одной, и проверочная, техническая сторона в другой.

	В представлении flights_v реализуется соединение таблиц flights и airports. Можно считать эту логику взглядом на рейс с точки зрения двух связанных этим рейсом аэропортов.
	
	В материализованном представлении routes данные о рейсах представлены без привязки к датам и обогащены информацией из airports  с городами. 

	Бизнес-область БД — авиаперелёты внутри России. При этом финансовой части и пассажирам  в ней уделено минимальное внимание, данные в большинстве своём касаются географических и хозяйственных аспектов перелётов.
	
	Из БД можно извлекать данные о всей совокупности перелётов или каждом перелёте в отдельности, и рассматривать их/его с точки зрения аэропорта/города/модели самолёта/количества купленных билетов/общей стоимости/времени полёта.
	Допустим, мы можем получить стоимость всех купленных билетов по каждому направлению за определённый период (посчитать выручку) и соотношение этой стоимости к количеству перелётов . Сравнить все перелёты и получить рейсы с самым большим денежным потоком. Или сравнить количество всех перелётов и стоимости по моделям самолётов — сформировать гипотезу о наиболее используемом с этой точки зрения модели, чтобы иметь представление о том, как в дальнейшем пополнять транспортный парк.
	
	
 
5. Список SQL запросов из приложения №2 с описанием логики их выполнения.

	Запросы в отдельном sql-файле.
	
	Логика запросов:
	
	Задание 1: Все города находятся в таблице airports и однозначно определяются именами-кодами аэропортов. Выбираем  города и счёт количества аэропортов по 
	кодам из таблицы, фильтруем по условию, где количество больше 1. Получаем 2 города — Москву и Ульяновск.

	Задание 2: Информация о рейсах находится в таблице flights, сам рейс определяется departure_airport(dp) и arrival_airport(ap). Теоретически, может существовать дальний рейс в одном направлении, поэтому с помощью оператора UNION объединим dp и ap – эта операция также исключит все повторы и не понадобится использовать DISTINCT. Информация о дальности самолёта находится в aircrafts: Выведем дальность самолёта через ORDER по убыванию и ограничим вывод единственной строкой. Объединим по именам-кодам аэропортов две таблицы — получим 7 аэропортов.

	Задание 3:  В данном задании содержится некоторая неопределённость.
		 С одной стороны, задержка по времени вылета однозначно определяется разницей между scheduled_departure и actual_departure из таблицы flights. В  таком случае достаточно профильтровать данные, убрав невылетевшие самолёты (IS NOT NULL) и с помощью оператора LIMIT вывести 10 рейсов в порядке убывания величины этой разницы.
		С другой — в таблице flights имеется атрибут status со значением Delayed (задержан) и сама БД дана в конкретный момент времени ( bookings.now( ) ). Первый вариант решения выдаст данные по уже свершившимся вылетам, но не даст информации по текущим рейсам со статусом «задержан».  Добавления CASE с условием status = 'Delayed'  даст информацию по рейсам, которые задерживаются именно сейчас, в момент времени bookings.now( ).


	Задание 4: Брони находятся в таблице bookings, посадочные талоны(boarding_no) в boarding_passses. INNER JOIN к tickets по book_ref и LEFT OUTER JOIN к boarding_pasess – так получим все возможные boarding_no  со значением NULL. 


	Задание 5:  Подсчитаем во внутреннем подзапросе количество мест для каждой модели самолёта, воспользовавшись таблицей seats. Объединим результат с таблицами flights и boarding_passes по типу самолёта и идентификатору перелёта соответственно во внешнем подзапросе . Подсчитаем ticket_no в окне по каждому перелёту, затем вычтем это количество из общего количества мест из первого подзапроса, затем выведем процентное соотношение мест — так решим первую часть задания. 
	Для решения второй части возьмем также дату вылета и аэропорт вылета из той же flights  во внешнем подзапросе и в главном запросе просуммируем через окно по аэропорту и дате, изменив тип данных на просто date (столбец с датой timestamp в выводе при этом оставим  для наглядности накопления пассажиров  в течение дня), порядок поставим по дате. Выведем также код аэропорта для наглядности.

	Задание 6: Необходимы 2 таблицы — flights и aircrafts. В подзапросе посчитаем все рейсы,  через оконные функции выведем количество рейсов по каждой модели самолёта и общую сумму всех рейсов/перелётов. Объединим результат  с таблицей
	aircrafts по aircraft_code, разделим количество рейсов по модели на общую сумму, округлим.

	Задание 7:  Сделаем 2 cte с данными из таблицы ticket_flights , в одно выбрав все перелёты и стоимость билетов со значением Business в fare_conditions, в другое — со значением Economy. Объединим с таблицей airports c условием и выберем все города с условием, что стоимость билета из cte с Economy больше стоимости из cte с Business.
	Получим, что таких городов нет.

	Задание 8:  В этой задаче одна сложность — факт того, что в БД имеются города с несколькими аэропортами и сами города при этом занесены в таблицу аэропортов.
	
      Первый вариант решения: сделаем подзапрос, внутри которого сперва получим декартово произведение имён-кодов аэропортов, помножив все коды из airports на самих себя. Потом вычтем из них все пары имён-кодов аэропортов из flights. Получим всё множество пар имён-кодов аэропортов, между которыми нет перелётов. Присоединим дважды к результату airports, чтобы получить непосредственно имена городов и выведем также имена-коды аэропортов. Декартово произведение самих городов, так же как невывод кодов аэропортов создаёт путаницу с городами, в которых несколько аэропортов.  Получим 618 уникальных рейсов и 10198 пар городов-аэропортов без прямых перелётов.
	
	Второй вариант:  воспользуемся мат. представлением routes, в котором есть имена городов. Заменим flights из первого варианта на  routes и выведем результат без присоединения каких-либо ещё таблиц и вывода кодов аэропортов. Получим 9685 пар городов без прямых перелётов. Разница с ответом из первого вариант возникает из-за городов с несколькими аэропортами.
	Использование routes является денормализацией. Однако, этот запрос стоит почти в три раза меньше, выполняется почти в три раза быстрее и читается легче первого.

	Создание представления из обоих запросов одинаково.

	Задание 9:  Сделаем несколько cte: в первом объединим departure_airport и arrival_airport из flights с моделью самолёта и его дальностью из aircrafts;
	в двух других выведем коды аэропортов с их координатами из airports. В главном запросе объединим первый cte с двумя другими по  departure_airport и  arrival_airport соответственно. Подставим значения в расчётную формулу и сделаем проверочный CASE по дальности полёта. Слава богу, все долетают, аж до Камчатки.
